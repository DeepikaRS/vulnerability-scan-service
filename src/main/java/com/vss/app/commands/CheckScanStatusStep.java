package com.vss.app.commands;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.vss.app.model.CheckScanStatusResponse;
import com.vss.app.model.ScanResult;
import com.vss.app.model.UploadContext;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.net.URI;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Service
@Slf4j
public class CheckScanStatusStep extends ScanStep {
    private final RestTemplate restTemplate = new RestTemplate();
    private final ObjectMapper objectMapper = new ObjectMapper();
    private static final int MAX_RETRIES = 5;
    private static final long RETRY_DELAY_MS = 2000;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    public void execute(UploadContext context) {
        checkUploadStatusWithRetryAsync(context.getUploadId(), 0)
                .thenAccept(status -> handleResult(context, status))
                .exceptionally(ex -> {
                    log.error("Failed to get upload status: {}", ex.getMessage());
                    return null;
                });
    }

    private CompletableFuture<Integer> checkUploadStatusWithRetryAsync(String uploadId, int retries) {
        return CompletableFuture.supplyAsync(() -> getStatus(uploadId))
                .thenCompose(status -> (status != null && status.getProgress() == 100) ?
                        CompletableFuture.completedFuture(status.getVulnerabilitiesFound()) :
                        retryOrFail(uploadId, retries));
    }

    private CompletableFuture<Integer> retryOrFail(String uploadId, int retries) {
        if (retries < MAX_RETRIES) {
            log.info("Status: Still processing. Retrying attempt {}", retries + 1);
            return scheduleRetry(uploadId, retries + 1);
        } else {
            log.error("Max retries reached. Upload status is still pending.");
            return CompletableFuture.failedFuture(new RuntimeException("Max retries reached"));
        }
    }

    private CompletableFuture<Integer> scheduleRetry(String uploadId, int retries) {
        CompletableFuture<Integer> future = new CompletableFuture<>();
        scheduler.schedule(() -> checkUploadStatusWithRetryAsync(uploadId, retries)
                .thenAccept(future::complete)
                .exceptionally(ex -> {
                    future.completeExceptionally(ex);
                    return null;
                }), RETRY_DELAY_MS, TimeUnit.MILLISECONDS);
        return future;
    }

    private CheckScanStatusResponse getStatus(String uploadId) {
        try {
            return checkUploadStatus(uploadId);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private CheckScanStatusResponse checkUploadStatus(String uploadId) throws IOException {
        String externalApiUrl = "https://debricked.com/api/1.0/open/ci/upload/status?ciUploadId=" + uploadId;
        ResponseEntity<String> response = restTemplate.exchange(
                RequestEntity.get(URI.create(externalApiUrl))
                        .header("Authorization", "Bearer " + jwtToken)
                        .build(),
                String.class);

        if (response.getStatusCode() == HttpStatus.OK) {
            return objectMapper.readValue(response.getBody(), CheckScanStatusResponse.class);
        }
        return null;
    }

    private void handleResult(UploadContext context, int status) {
        context.setScanResult(ScanResult.builder().vulnerabilitiesCount(status)
                .fileNames(fileNameString(context.getFiles())).build());
        try {
            next(context);
            log.info("Scan completed successfully!!");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private String fileNameString(MultipartFile[] files){
        StringBuilder fileNameStrBuilder = new StringBuilder();
        for(MultipartFile file : files){
            fileNameStrBuilder.append(file.getName());
            fileNameStrBuilder.append(" ,");
        }
        return fileNameStrBuilder.toString();
    }
}
